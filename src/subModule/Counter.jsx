/* 
    useState 생성자 함수를 사용하기 위한 임포트 필수
*/
import { useState } from "react";
/* 
    <Hook>
    - 비동기적 처리를 위한 고리를 생성한다는 개념
*/
/* 
    리액트 에서는 이벤트 발생에 따른 비동기 처리시 컴포넌트에 구현한 값의 변경을 위해서는
    별도의 비동기값(상태값)이 필요. 즉, 비동기 값이 변경되면 코드파싱이 다시 일어나
    리랜더링이 발생.
    이러한 비동기값(상태값)의 생성을 위해서는 useState 함수를 이용해야 하며, 지정된 변수는
    set~ 함수를 통해서만 값의 변경이 가능. (set~ 형식은 관례상 표기 )
    함수(객체) 내에 일반적으로 정의된 지역변수는 그 특성상 값을 유지하지 못하고 함수 외부의
    전역변수 또한 각 컴포넌트의 개별 고유값이 아니므로 함수 내에서 변경한다 하더라도
    변경되지 않음.

    형식 : const [ 변수명, set_함수 ] = useState(초기값);

    set_함수 : set 함수의 명칭은 변수명 앞에 관례상 접두사 set을 지정하는 것이 일반적
    초기값 : 변수에 최초에 지정할 디폴트 값.
*/

function Counter({ spanStyle, btnStyle }) {
    /*
        useState 함수는 변수에 할당된 값과 변경 함수의 참조를 배열 형태로 반환
        따라서 구조분해 할당(Destructuring Assignment)을 통한 초기화가 일반적

    ※   React Hook(비동기 함수들의 호칭)은 함수 컴포넌트 내에서만 전역적으로 호출 
    가능함으로써 컴포넌트 내에 선언된 함수 내에서 지역적으로 호출 불가함에 주의
    */
    const [count, setCount] = useState(0);

    return (
        <>
            <div>COUNTER
                <span style={spanStyle}>{count}</span>
            </div>
            {/* 
            <상태값에 대한 일반 업데이트>
            setCount 함수의 실인수 전달을 통한 비동기값(count)의 변경
            상태값의 업데이트는 항상 새로운 겂으로 덮어쓰는 것이지, 기존 상태값 자체를
            변경하는 것은 불가

        ※  리액트에서의 상태 업데이트애 대한 기본 사상은 원본 불변을 원칙으로함.
            이는 상태값에 대한 원본을 유지한 상태에서 변경된 데이터를 덮어쓰는 것을 의미
            하는 것으로써, 이렇게 함으로써의 이득은 상태가 변경될 떄마다 변경포인트를 
            내부적으로 기록하여 상태값의 깊은 데이터까지 모두 비교하는 것이 아니라, 변경
            포인트를 측정하여 표면적인 변경상태 여부만 측정함으로써 비교를 최소화하여
            최적화를 달성.
            만약 이 원칙을 지키지 안흔다면 매번 상태 변경시 마다 내부 깊은 데이터 까지
            모두 비교하는 현상이 발생되어, 프로그래밍 최적화가 불가 
        */}
            {/* <button style={btnStyle} onClick={() => setCount(count + 1)}>+1</button>
            <button style={btnStyle} onClick={() => setCount(count - 1)}>-1</button> */}
            {/* 위의 방식으로 코딩하면 함수가 계속 만들었다 사라지는 것을 반복함 */}
            {/* 
                <상태값에 대한 함수형 업데이트>
                setCount 함수에 익명객체의 참조를 정달하되 이에 대한 매개변수를 지정함 으로써
                콜백 호출을 통해 전달받은 매개변수에서 읽어들인 비동기값(count)을 이용하여
                가공하고 가공한 그결과값을 반환받앙 비동기값을 업데이트하는 방식
                익명객체 적용시 매개변수는 최근접 변수에 수렴되므로 상태값 변수와 동일한
                식별자를 사용해도 무방

                위와 같은 방식은 함수 표현식에 대한 호출과 같이 렌더링시 마다 새로운 함수를 
                생성하여 전달하는 반면, 하기의 방식은 렌더링시 마다 함수를 재생성하는 것이 아닌, 
                최초 정의한 콜백함수의 참조를 랜더링시 마다 전달함으로써 컴포넌트 회적화에 유리
                또한 상태값 변경을 위해 하위 컴포넌트에서 setter 함수만 필요한 경우에도 굳이
                상태값을 프롭스로 전달할 필요가 없다는 장점
            */}
            {/* 최적화에는 위의 코드보다 아래가 유리함 */}
            <button style={btnStyle} onClick={() => setCount(c => c + 1)}>+1</button>
            <button style={btnStyle} onClick={() => setCount(c => c - 1)}>-1</button>
        </>
    );
}

export default Counter;